/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useState, useEffect } from 'react'
import { useLoader, useFrame } from 'react-three-fiber'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader'
import { useSpring, animated as a } from 'react-spring/three'
import propellerImg from '../images/propeller.png'

import buttonAudio from '../audio/button-click.mp3';
import buttonInactiveAudio from '../audio/button-inactive.mp3';
import servo1Audio from '../audio/servo1.mp3';
import servo2Audio from '../audio/servo2.mp3';
import servo3Audio from '../audio/servo3.mp3';

const buttonSound = new Audio(buttonAudio);
const buttonInactiveSound = new Audio(buttonInactiveAudio);
const servo1Sound = new Audio(servo1Audio);
const servo2Sound = new Audio(servo2Audio);
const servo3Sound = new Audio(servo3Audio);

function playAudio(audio, volume = 1, loop = false) {
    audio.currentTime = 0
    audio.volume = volume
    audio.loop = loop
    audio.play()
}

function playRandomServo() {
  const vol = .75;
  const rand = Math.floor(Math.random() * 3) + 1;

  switch(rand) {
    case 1:
      playAudio(servo1Sound, vol, false);
      return;
    case 2:
      playAudio(servo2Sound, vol, false);
      return;
    default:
      playAudio(servo3Sound, vol, false);
  }
}

function GFCMachine({selections, allowSound, setModelLoaded, setNewSelection}) {
  const group = useRef();
  const outerGroup = useRef();
  const { nodes, materials } = useLoader(GLTFLoader, 'gfc-hq.glb', loader => {
    const dracoLoader = new DRACOLoader()
    dracoLoader.setDecoderPath('draco-gltf/')
    loader.setDRACOLoader(dracoLoader)
  })

  const [hovered, setHover] = useState(false);
  useEffect(() => void (document.body.style.cursor = hovered ? 'pointer' : 'auto'), [hovered]);

  //Start CSS
  React.useEffect(() => {
      setModelLoaded(true);
  }, []);

  const [propellerTex] = useLoader(THREE.TextureLoader, [propellerImg])

  const propeller = useRef();
  const sphere = useRef(); //only for init spinning
  useFrame( ({ clock }) => {
      propeller.current.rotation.y += .4;
      
      if(sphere.current !== null && selections.length < 2) {
        sphere.current.rotation.y += .04;
      }

      outerGroup.current.position.y = Math.sin(clock.getElapsedTime() * 1.1) * .057 + 0.1;
      outerGroup.current.position.x = Math.sin(clock.getElapsedTime() * 1.5) * .05;
      outerGroup.current.position.z = Math.sin(clock.getElapsedTime() * 1.3) * .05;
      outerGroup.current.rotation.y = -Math.sin(clock.getElapsedTime() * .25) * .25 - 1.60; //speed, amount, rotation tweak
    }
  )

  const handleClick = (id) => { 
    if(!isActive(id)){
      if(allowSound){
        playRandomServo();
        playAudio(buttonSound, 1, false);
      }
      setNewSelection(id);
    } else {
      if(allowSound){
        playAudio(buttonInactiveSound, 1, false);
      }
    }
  }
  
  const isActive = (selection) => {
    return selections.includes(selection)
  }

  const [initLights, setInitLights] = useState(['good', 'fast', 'cheap']);
  const [initLightsIdx, setInitLightsIdx] = useState(0);
  
  useEffect(() => {
    let interval;
    window.clearInterval(interval);
    if(selections.length === 2) {
      window.clearInterval(interval);
      setInitLights([]);
    } else {
      const filteredInitLights = initLights.filter(i => i !== selections[0])
      interval = window.setInterval(() => {
        setInitLightsIdx(idx => (idx + 1) % filteredInitLights.length);
      }, 700)
      setInitLights(filteredInitLights);
    }

    return () => window.clearInterval(interval);
  }, [selections])


  const isInitActive = (selection) => {
    return selection === initLights[initLightsIdx]
  }


  const sphereRotVal = () => {
    //HACK I don't know why I have to do this but putting this default spin
    //masks the fact that the init constant spin doesn't seemlessly animate
    //into the Spring animation when the first 2 selections are made.
    //Whithout this, the first 2 selections just pops to some selections.
    //See never/always comments below
    if (selections.length < 2) {
      return 5;
    }

    if(selections.every(s => s !== 'good')) { //never animates on first selection (wtf?)
        return Math.PI/1.5;
    } else if(selections.every(s => s !== 'fast')) {
        return 0;
    } else if(selections.every(s => s !== 'cheap')) { //always animates on first selection (wtf?)
        return -Math.PI/1.5;
    } 
  }

  
  const {buttonPos1, buttonPos2, buttonPos3} = useSpring({
    buttonPos1: isActive('good') ? -.06 : .06,
    buttonPos2: isActive('fast') ? -.06 : .06,
    buttonPos3: isActive('cheap') ? -.06 : .06,
    config: { duration: 150 }
  })

  const {arrowRot1, arrowRot2, arrowRot3} = useSpring({
    arrowRot1: isActive('good') ? Math.PI : 0,
    arrowRot2: isActive('fast') ? Math.PI : 0,
    arrowRot3: isActive('cheap') ? Math.PI : 0,
    config: { mass: 1, tension: 150, friction: 12 }
  })

  const {sphereRot} = useSpring({
    to: {sphereRot: sphereRotVal()},
    from: {sphereRot: 16}
  })

  const {machineY} = useSpring({
    to: {machineY: 0},
    from: {machineY: 3.2},
    delay: 500,
    config: { mass: 1, tension: 280, friction: 120 }
  })

  return (
    <a.group 
      ref={outerGroup} 
      dispose={null} 
    > 
      <a.group 
        ref={group} 
        dispose={null} 
        position = {machineY.interpolate(y => [0, y, 0])} 
      > 
        <mesh material={materials['gfc main']} geometry={nodes.casing.geometry} position={[0, 0, 0]}>


          {/* ARROWS */}
          <a.mesh 
            material={materials['gfc main']} 
            geometry={nodes.arrow1.geometry} 
            position={[0.38, 0.06, 0.35]} 
            rotation={arrowRot1.interpolate(r => [r, 0, 0])}
          />
          <a.mesh 
            material={materials['gfc main']} 
            geometry={nodes.arrow2.geometry} 
            position={[0.38, 0.06, -0.35]} 
            rotation={arrowRot2.interpolate(r => [r, 0, 0])}
          />
          <a.mesh 
            material={materials['gfc main']} 
            geometry={nodes.arrow3.geometry} 
            position={[0.38, -0.54, 0]} 
            rotation={arrowRot3.interpolate(r => [r, 0, 0])}
          />


          {/* BUTTONS */}
          <a.mesh 
            material={materials['gfc main']} 
            geometry={nodes.button1.geometry} 
            position={buttonPos1.interpolate(p => [p, 0.33, 0.83])} 
            onPointerOver={() => setHover(true)} 
            onPointerOut={() => setHover(false)}
            onPointerDown={() => handleClick('good')}
          />
          <a.mesh 
            material={materials['gfc main']} 
            geometry={nodes.button2.geometry} 
            position={buttonPos2.interpolate(p => [p, 0.33, -0.82])}
            onPointerOver={() => setHover(true)} 
            onPointerOut={() => setHover(false)}
            onPointerDown={() => handleClick('fast')}
          />
          <a.mesh 
            material={materials['gfc main']} 
            geometry={nodes.button3.geometry} 
            position={buttonPos3.interpolate(p => [p, -1.09, 0])} 
            onPointerOver={() => setHover(true)} 
            onPointerOut={() => setHover(false)}
            onPointerDown={() => handleClick('cheap')}
          />


          {/* LIGHTS */}
          <mesh material={nodes.light1.material} geometry={nodes.light1.geometry}>
            <meshPhongMaterial 
              attach = "material"
              color = {new THREE.Color('#010201')}
              emissive = {new THREE.Color('#00ff00')}
              emissiveIntensity = {isActive('good') || isInitActive('good') ? 50 : 0}
            />
          </mesh>
          <mesh material={nodes.light2.material} geometry={nodes.light2.geometry}>
            <meshPhongMaterial 
              attach = "material" 
              color = {new THREE.Color('#010201')}
              emissive = {new THREE.Color('#00ff00')}
              emissiveIntensity = {isActive('fast') || isInitActive('fast') ? 50 : 0}
            />
          </mesh>
          <mesh material={nodes.light3.material} geometry={nodes.light3.geometry}>
            <meshPhongMaterial 
              attach = "material" 
              color = {new THREE.Color('#010201')}
              emissive = {new THREE.Color('#00ff00')}
              emissiveIntensity = {isActive('cheap') || isInitActive('cheap') ? 50 : 0}
            />
          </mesh>


          {/* SPHERE */}
          {selections.length === 2
          ?
            <a.mesh ref={sphere}
              material={materials['gfc main']} 
              geometry={nodes.sphere.geometry} 
              position={[0.18, -0.14, 0]}  
              rotation={sphereRot.interpolate(r => [0, r, 0])}
            />
            :
            <a.mesh ref={sphere}
              material={materials['gfc main']} 
              geometry={nodes.sphere.geometry} 
              position={[0.18, -0.14, 0]}
            />
          }
          

          {/* PROPELLER */}
          <group ref={propeller} position={[-0.01, 0.86, 0]}>
            <mesh material={materials['gfc main']} geometry={nodes.propeller_0.geometry} />
            <mesh geometry = {nodes.propeller_1.geometry}>
              <meshStandardMaterial
                attach="material" 
                map={propellerTex} 
                side={THREE.DoubleSide}
                transparent
              />
            </mesh>
          </group>
        </mesh>
      </a.group>
    </a.group>
  )
}

export default GFCMachine;